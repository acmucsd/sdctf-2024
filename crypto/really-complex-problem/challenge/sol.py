from CRSA import *
import binascii
N = GaussianRational(Fraction(-117299665605343495500066013555546076891571528636736883265983243281045565874069282036132569271343532425435403925990694272204217691971976685920273893973797616802516331406709922157786766589075886459162920695874603236839806916925542657466542953678792969287219257233403203242858179791740250326198622797423733569670), Fraction(617172569155876114160249979318183957086418478036314203819815011219450427773053947820677575617572314219592171759604357329173777288097332855501264419608220917546700717670558690359302077360008042395300149918398522094125315589513372914540059665197629643888216132356902179279651187843326175381385350379751159740993))
c = GaussianRational(Fraction(49273345737246996726590603353583355178086800698760969592130868354337851978351471620667942269644899697191123465795949428583500297970396171368191380368221413824213319974264518589870025675552877945771766939806196622646891697942424667182133501533291103995066016684839583945343041150542055544031158418413191646229), Fraction(-258624816670939796343917171898007336047104253546023541021805133600172647188279270782668737543819875707355397458629869509819636079018227591566061982865881273727207354775997401017597055968919568730868113094991808052722711447543117755613371129719806669399182197476597667418343491111520020195254569779326204447367))
e = 65537

# factorize the norm of N - just throw into Alpertron or something, this is factorizable on a laptop
p = 652396096643676367544566156124913216163410921734827378316264717178043201248098216744333182034733046461246836969083455954245444287495898970654732184830855419214640885149170735361071243374488441853305632933085361898289750475979418539227694088799586535639304205925186104659033478286855260238037651424137268151709
q = 604941068317189652627858851523167292428948871043205807414277515111804456754639695955081185290003101108400607518848813115420632093104992473355039185637288241681868004615473802877209913302613123923904488351942249382653677543786493647849046273946794244961213693227449138212955169271151864267238394436697214152361

tot = (p - 1) * (q - 1)

d = pow(e, -1, tot)
m = pow(c, d, N)

# In reality there are four possible remainders with norm smaller than N
# this function shows what these four possible remainders are
def reduce_mod(self, N):
    x = self/N
    y1 = GaussianRational(Fraction(floor(x.real)), Fraction(floor(x.imag)))
    y2 = GaussianRational(Fraction(floor(x.real)), Fraction(ceil(x.imag)))
    y3 = GaussianRational(Fraction(ceil(x.real)), Fraction(floor(x.imag)))
    y4 = GaussianRational(Fraction(ceil(x.real)), Fraction(ceil(x.imag)))
    ys = [y1,y2,y3,y4]
    assert(all(y.real*y.real + y.imag+y.imag < N.real*N.real + N.imag*N.imag for y in ys))
    return tuple(self - y*N for y in ys)

answers = reduce_mod(m, N)

for answer in answers:
    # find the one with positive real/imag components
    if (answer.real > 0 and answer.imag > 0):
        flag1 = binascii.unhexlify(hex(int(answer.real))[2:]).decode()
        flag2 = binascii.unhexlify(hex(int(answer.imag))[2:]).decode()
        print(f"{flag1}{flag2}")